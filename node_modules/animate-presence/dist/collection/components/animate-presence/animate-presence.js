import { h, Host } from "@stencil/core";
import { setCustomProperties, isHTMLElement, hasData, presence, closest, enterChildren, exitChildren, injectGlobalStyle, } from '../../utils';
const hold = (el) => async (cb) => {
    el.dataset.hold = '';
    await cb(el).then((r) => {
        if (r && 'finished' in r) {
            return r.finished;
        }
        return;
    });
    delete el.dataset.hold;
};
export class AnimatePresence {
    constructor() {
        /** @internal */
        this.__presenceKey = `animate-presence-${ids++}`;
        /** @internal */
        this.descendants = [];
        this.getClosestParent = () => {
            var _a;
            const base = (_a = this.element.parentElement, (_a !== null && _a !== void 0 ? _a : this.element.getRootNode().host));
            return closest(this.element.tagName, base);
        };
        this.willExit = false;
        this.didExit = false;
        this.willEnter = false;
        this.didEnter = false;
        this.handleMutation = this.handleMutation.bind(this);
    }
    observeChanged() {
        if (this.observe) {
            this.addMO();
            this.mo.observe(this.element, {
                childList: true,
                attributes: true,
                attributeFilter: ['data-key'],
            });
        }
        else {
            this.removeMO();
        }
    }
    async componentWillLoad() {
        var _a, _b;
        injectGlobalStyle();
        this.ancestor = this.getClosestParent();
        if (typeof this.observe === 'undefined') {
            this.observe = (_b = (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.observe, (_b !== null && _b !== void 0 ? _b : true));
        }
        Array.from(this.element.children).map((el, i) => {
            setCustomProperties(el, { i });
            el.style.setProperty('animation-play-state', 'paused');
            el.dataset.enter = '';
        });
    }
    async componentDidLoad() {
        var _a;
        this.observeChanged();
        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.registerChild(this.element);
        if (!this.ancestor) {
            this.enter();
        }
    }
    async componentDidUnload() {
        var _a;
        this.removeMO();
        (_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.unregisterChild(this.__presenceKey);
        this.descendants = [];
    }
    async enterNode(el, i = 0) {
        delete el.dataset.exit;
        const event = new CustomEvent('animatePresenceEnter', {
            bubbles: true,
            detail: {
                i,
                hold: hold(el),
            },
        });
        el.dispatchEvent(event);
        el.style.removeProperty('animation-play-state');
        el.dataset.enter = '';
        setCustomProperties(el, { i });
        await presence(el, {
            afterSelf: async () => {
                delete el.dataset.initial;
                delete el.dataset.enter;
                el.style.removeProperty('--i');
            },
        });
        return enterChildren(el);
    }
    async exitNode(el, method = 'remove', i = 0) {
        await exitChildren(el);
        delete el.dataset.willExit;
        setCustomProperties(el, { i });
        const event = new CustomEvent('animatePresenceExit', {
            bubbles: true,
            detail: {
                i,
                hold: hold(el),
            },
        });
        el.dispatchEvent(event);
        el.dataset.exit = '';
        await presence(el, {
            afterSelf: () => {
                if (method === 'remove') {
                    el.remove();
                }
                else if (method === 'hide') {
                    el.style.setProperty('visibility', 'hidden');
                }
            },
        });
        return Promise.resolve();
    }
    async handleEnter(node, _record, i) {
        if (!isHTMLElement(node))
            return;
        if (hasData(node, 'exit'))
            return;
        if (hasData(node, 'willExit')) {
            return this.exitNode(node, 'remove', i);
        }
        else {
            return this.enterNode(node, i);
        }
    }
    async handleExit(node, record, i) {
        if (!isHTMLElement(node))
            return;
        if (hasData(node, 'exit') || hasData(node, 'willExit')) {
            return;
        }
        node.dataset.willExit = '';
        setCustomProperties(node, { i });
        if (isHTMLElement(record.previousSibling)) {
            record.previousSibling.insertAdjacentElement('afterend', node);
        }
        else if (isHTMLElement(record.target)) {
            record.target.prepend(node);
        }
    }
    handleMutation(records) {
        let i = 0;
        for (const record of records.reverse()) {
            if (record.addedNodes.length === 1) {
                this.handleEnter(record.addedNodes[0], record, records.length - 1 - i);
            }
            if (record.removedNodes.length === 1) {
                this.handleExit(record.removedNodes[0], record, i);
            }
            i++;
        }
    }
    addMO() {
        if (!this.mo) {
            if ('MutationObserver' in window) {
                this.mo = new MutationObserver(this.handleMutation);
                this.observeChanged();
            }
        }
    }
    removeMO() {
        if (this.mo) {
            this.mo.disconnect();
            this.mo = undefined;
        }
    }
    /** @internal Registers a child element across shadow boundaries */
    async registerChild(el) {
        const key = el.__presenceKey;
        // Remove existing elements with same key to handle HMR
        this.descendants = [
            ...this.descendants.filter(element => element.__presenceKey !== key),
            el,
        ];
        return;
    }
    /** @internal */
    async unregisterChild(key) {
        this.descendants = this.descendants.filter(el => el.__presenceKey !== key);
        return;
    }
    animatePresenceExitCompleteHandler(event) {
        event.stopPropagation();
    }
    /**
     * Programmatically triggers an exit.
     *
     * Nested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.
     */
    async exit() {
        if (this.didExit || this.willExit)
            return;
        this.willExit = true;
        await Promise.all(Array.from(this.element.children)
            .reverse()
            .map((el, i) => this.exitNode(el, 'hide', i)));
        this.didExit = true;
        this.willExit = false;
        this.animatePresenceExitComplete.emit();
        return Promise.resolve();
    }
    /**
     * Programmatically triggers an entrance.
     *
     * Nested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.
     */
    async enter() {
        this.didExit = false;
        this.willExit = false;
        if (this.didEnter || this.willEnter)
            return;
        this.willEnter = true;
        await Promise.all(Array.from(this.element.children).map((el, i) => this.enterNode(el, i)));
        await enterChildren(this.element);
        this.didEnter = true;
        this.willEnter = false;
        return Promise.resolve();
    }
    render() {
        return (h(Host, { style: { display: 'contents' } },
            h("slot", null)));
    }
    static get is() { return "animate-presence"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "__presenceKey": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": undefined,
                        "name": "internal"
                    }],
                "text": ""
            },
            "attribute": "__presence-key",
            "reflect": false,
            "defaultValue": "`animate-presence-${ids++}`"
        },
        "descendants": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "HTMLAnimatePresenceElement[]",
                "resolved": "HTMLAnimatePresenceElement[]",
                "references": {
                    "HTMLAnimatePresenceElement": {
                        "location": "global"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": undefined,
                        "name": "internal"
                    }],
                "text": ""
            },
            "defaultValue": "[]"
        },
        "observe": {
            "type": "boolean",
            "mutable": true,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "If `true` (default), a MutationObserver will automatically be connected to enable animations when a child node enters/exits.\n\nIf you know the children are static (typical `animated-route-switch` use case), `false` may improve performance.\n\nNote: `<animate-presence>` elements which are children of a parent `<animate-presence>` element will inherit this value,\n\nwhich means MutationObservers can be disabled for the entire tree by setting `observe={false}` on the top-level element.\n\nHowever, directly set values always take precedence over inherited values."
            },
            "attribute": "observe",
            "reflect": false
        }
    }; }
    static get events() { return [{
            "method": "animatePresenceExitComplete",
            "name": "animatePresenceExitComplete",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Fires when all exiting nodes have completed animating out.\n\nTo simplify listener behavior, this event bubbles, but never beyond the closest `<animate-presence>` parent."
            },
            "complexType": {
                "original": "void",
                "resolved": "void",
                "references": {}
            }
        }, {
            "method": "animatePresenceEnter",
            "name": "animatePresenceEnter",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Dispatched on a child when it enters. `event.target` is the entering child element.\n\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event."
            },
            "complexType": {
                "original": "{ i: number }",
                "resolved": "{ i: number; }",
                "references": {}
            }
        }, {
            "method": "animatePresenceExit",
            "name": "animatePresenceExit",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "Dispatched on a child when it exits. `event.target` is the exiting child element.\n\nIt is recommended to use an animation handler created with `createPresenceHandler` for this event."
            },
            "complexType": {
                "original": "{ i: number }",
                "resolved": "{ i: number; }",
                "references": {}
            }
        }]; }
    static get methods() { return {
        "registerChild": {
            "complexType": {
                "signature": "(el: HTMLAnimatePresenceElement) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLAnimatePresenceElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "",
                "tags": [{
                        "name": "internal",
                        "text": "Registers a child element across shadow boundaries"
                    }]
            }
        },
        "unregisterChild": {
            "complexType": {
                "signature": "(key: string) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "",
                "tags": [{
                        "name": "internal",
                        "text": undefined
                    }]
            }
        },
        "exit": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Programmatically triggers an exit.\n\nNested `<animate-presence>` children will be animated out from the bottom up, meaning that children elements trigger a parent's exit after their own exit finishes.",
                "tags": []
            }
        },
        "enter": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Programmatically triggers an entrance.\n\nNested `<animate-presence>` children will be animated in from the top down, meaning that parent elements trigger a child's entrance after their own entrance finishes.",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "element"; }
    static get watchers() { return [{
            "propName": "observe",
            "methodName": "observeChanged"
        }]; }
    static get listeners() { return [{
            "name": "animatePresenceExitComplete",
            "method": "animatePresenceExitCompleteHandler",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
let ids = 0;
