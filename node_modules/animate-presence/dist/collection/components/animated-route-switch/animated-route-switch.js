import { h } from "@stencil/core";
import { matchPath } from '../../utils/router';
import { enterChildren, exitChildren } from '../../utils';
const getUniqueId = () => {
    return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');
};
const getMatch = (pathname, url, exact) => {
    return matchPath(pathname, {
        path: url,
        exact: exact,
        strict: true,
    });
};
const isHTMLStencilRouteElement = (elm) => {
    return elm.tagName === 'STENCIL-ROUTE';
};
export class AnimatedRouteSwitch {
    constructor() {
        /** @internal */
        this.group = getUniqueId();
        this.subscribers = [];
    }
    componentWillLoad() {
        if (this.location != null) {
            this.regenerateSubscribers(this.location);
        }
        else {
            console.warn(`<animated-route-switch> requires the "location" prop in order to be wired to Stencil Router.`);
        }
    }
    async regenerateSubscribers(newLocation) {
        console.log(newLocation);
        if (newLocation == null) {
            return;
        }
        let newActiveIndex = -1;
        this.subscribers = Array.prototype.slice
            .call(this.el.children)
            .filter(isHTMLStencilRouteElement)
            .map((childElement, index) => {
            const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);
            if (match && newActiveIndex === -1) {
                newActiveIndex = index;
            }
            return {
                el: childElement,
                match: match,
            };
        });
        if (newActiveIndex === -1) {
            return;
        }
        // Check if this actually changes which child is active
        // then just pass the new match down if the active route isn't changing.
        if (this.activeIndex === newActiveIndex) {
            this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;
            return;
        }
        this.prevIndex = this.activeIndex;
        this.activeIndex = newActiveIndex;
        // Set all props on the new active route then wait until it says that it
        // is completed
        const prevChild = this.subscribers[this.prevIndex];
        if (prevChild) {
            await exitChildren(prevChild.el);
        }
        const activeChild = this.subscribers[this.activeIndex];
        if (typeof this.scrollTopOffset === 'number') {
            activeChild.el.scrollTopOffset = this.scrollTopOffset;
        }
        activeChild.el.group = this.group;
        activeChild.el.match = activeChild.match;
        activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {
            // After the new active route has completed then update visibility of routes
            this.queue.write(() => {
                this.subscribers.forEach((child, index) => {
                    child.el.componentUpdated = undefined;
                    if (index === this.activeIndex) {
                        child.el.style.display = '';
                        return enterChildren(child.el);
                    }
                    if (typeof this.scrollTopOffset === 'number') {
                        child.el.scrollTopOffset = this.scrollTopOffset;
                    }
                    child.el.group = this.group;
                    child.el.match = null;
                    child.el.style.display = 'none';
                });
            });
            if (this.routeViewsUpdated) {
                this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));
            }
        };
    }
    render() {
        return h("slot", null);
    }
    static get is() { return "animated-route-switch"; }
    static get properties() { return {
        "group": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": undefined,
                        "name": "internal"
                    }],
                "text": ""
            },
            "attribute": "group",
            "reflect": true,
            "defaultValue": "getUniqueId()"
        },
        "routeViewsUpdated": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(options: any) => void",
                "resolved": "(options: any) => void",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [{
                        "text": undefined,
                        "name": "internal"
                    }],
                "text": ""
            }
        },
        "scrollTopOffset": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "scroll-top-offset",
            "reflect": false
        },
        "location": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "LocationSegments",
                "resolved": "LocationSegments",
                "references": {
                    "LocationSegments": {
                        "location": "import",
                        "path": "../../utils/router"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        }
    }; }
    static get contextProps() { return [{
            "name": "queue",
            "context": "queue"
        }]; }
    static get elementRef() { return "el"; }
    static get watchers() { return [{
            "propName": "location",
            "methodName": "regenerateSubscribers"
        }]; }
}
